\chapter{Enforcing Constraints}

This chapter explains how the constraints are expressed and validated with the tool using both the general definition of a rule as well as by providing a modeled example system. The constraints are divided into three distinct categories. The first category contains the constraints that are possible to express in ArchUnit as-is. The second category describes constraints that are enforceable with the help of additional information in source code. The third and final category details constraints that require an extension of ArchUnit to be possible to enforce.

\section{Example system}\todo{improve heading}
The constraints used within the report are not system-specific but instead defined to by generally applicable. However, a toy system called \textit{BloggerWeb} has been modeled to allow us to showcase a specific example for each constraint. Blogger is by no means intended to be a complex or complete system, but rather big enough to provide the functionality to support the constraints. An UML class diagram of BlogWeb is illustrated in figure \ref{fig:toy_application}.

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{figure/ToyApp.png}
    \caption{An example of a system, for the purpose of illustrating how the constraints are applied.}
    \label{fig:toy_application}
\end{figure}

BlogWeb is, as the name suggests, a blog website providing users with the ability to publish statuses to their blogs. Being a website means that the system receives actions to execute via Http requests. These requests are received by the RequestHandler to be later forwarded to the UserService, which provides public methods for sign in and publishing a status update. The UserService has a reference to both a UserAuthorizer and a UserAuthenticator implementing the logic for authorization and authentication. The UserService also uses the Logger to perform the necessary logging of user requests. StatusSanitizer is used to sanitize the status updates received by users before its stored while OutBoundMessageSanitizer is responsible for sanitizing requests responses. Finally, as the RequestHandler may serve several users at once, a thread is spawned for each request to make the execution concurrent. 

\section{Support in ArchUnit as-is}\label{sec:as-is}

ArchUnit contains an extensive vocabulary for expressing typical architectural constraints. These constraints are generally composed of three parts. The first part indicates the type of Java construct that should be inspected. These constructs include classes, methods, fields and constructors. The second part contains a predicate that selects a subset of these constructs. The third part defines the condition that must hold true for all the selected constructs.

An example of a rule defined solely using this standard vocabulary can be seen in Listing~\ref{lst:standard_vocabulary}, where each of the three aforementioned parts of the constraint has been separated into their own line. The rule is a simple example of complete mediation, where some internal classes must only be accessed through a mediator.

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Example of a rule that is expressed with the standard vocabulary.}, captionpos=b, label=lst:standard_vocabulary, numbers=left]
ArchRule rule = classes()
    .that().resideInAPackage("..internal..")
    .should().onlyBeAccessed().byAnyPackage("..mediator..");
\end{lstlisting}
\end{minipage}

In situations where this vocabulary is insufficient for expressing a constraint, there is a possibility to define custom predicates and conditions over any given construct. These can be supplied as arguments to the \texttt{that()} and \texttt{should()} methods. Custom predicates and conditions are used extensively in our implementation, as will be made apparent in the following sections.

\subsection{Log all security events}
% Description
This constraint is expressed with the assumption that there are services, in the form of classes, that are responsible for performing security related events. Any publicly accessible methods in these services perform a security event and must therefore contain a call to the logging facility.

% Rule definition
The definition of the architectural rule can be seen in Listing~\ref{lst:constraint_1_impl}. The predicate that selects the security services, and the class that is responsible for logging, are passed as arguments to the architectural rule. This leaves no need for injecting information into the source code of the target system. Furthermore, by using a predicate to select the security services, the developer is left with some flexibility in how they decide to apply the constraint. As opposed to a plain list of classes, a predicate can match all classes belonging to a specific package or following a set naming scheme, minimizing the need for revisiting the constraint as the system evolves.

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Rule definition for constraint 1.}, captionpos=b, label=lst:constraint_1_impl, numbers=left]
ArchRule logSecurityEvents(
        DescribedPredicate<? super JavaClass> securityServicesDescriptor,
        Class<?> logger) {
    return methods()
        .that().haveModifier(JavaModifier.PUBLIC)
        .and().areDeclaredInClassesThat(securityServicesDescriptor)
        .should(callMethod(declaredIn(logger)));
}
\end{lstlisting}
\end{minipage}

% Applied to toy app
In the example system, illustrated in Figure~\ref{fig:toy_application}, the logging facility is the class named \texttt{Logger} while the only security service is the \texttt{UserService} class. An application of the constraint on this system can be as simple as the one shown in Listing~\ref{lst:constraint_1_toy}.

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Application of constraint 1 to the example system.}, captionpos=b, label=lst:constraint_1_toy, numbers=left]
@ArchTest
ArchRule logSecurityEvents = SecArchUnit
    .logSecurityEvents(type(UserService.class), Logger.class);
\end{lstlisting}
\end{minipage}

\subsection{Enforce AuthN/AuthZ at single point}
% Description
The second constraint is defined in terms of two concepts: an authentication point and an authentication enforcer. Authentication is performed through a method call to the authentication enforcer, which is a class whose sole responsibility is to authenticate an actor. This call should occur at the authentication point, and at no other points in the system, for the sake of ensuring a uniform authentication mechanism throughout the system. Authorization is enforced in the same manner, with the concepts of an authorization point and an authorization enforcer.

% Rule definition
The definition of the second constraint is detailed in Listing~\ref{lst:constraint_2_impl}. The constraint is defined as two separate rules, for the sake of clarity, but their implementations are identical.

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Rule definition for constraint 2.}, captionpos=b, label=lst:constraint_2_impl, numbers=left]
ArchRule enforceAuthenticationAtCentralPoint(
        Class<?> authenticationPoint,
        Class<?> authenticator) {
    return CompositeArchRule.of(
        theClass(authenticationPoint)
            .should(callMethod(declaredIn(authenticator)))
    ).and(
        methods()
            .that().areDeclaredIn(authenticator)
            .should(onlyBeAccessedBy(authenticationPoint))
    );
}

ArchRule enforceAuthorizationAtCentralPoint(
        Class<?> authorizationPoint,
        Class<?> authorizer) {
    return enforceAuthenticationAtCentralPoint(
        authorizationPoint,
        authorizer
    );
}
\end{lstlisting}
\end{minipage}

% Applied to toy app
In the example system, the authentication and authorization points are both situated in the \texttt{UserService} class while authentication and authorization are enforced by the classes \texttt{UserAuthenticator} and \texttt{UserAuthorizer} respectively. The application of the rule can be seen in Listing~\ref{lst:constraint_2_toy}.

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Application of constraint 2 to the example system.}, captionpos=b, label=lst:constraint_2_toy, numbers=left]
@ArchTest
ArchRule enforceAuthentication = SecArchUnit
    .enforceAuthenticationAtCentralPoint(UserService.class, UserAuthenticator.class);

@ArchTest
ArchRule enforceAuthorization = SecArchUnit
    .enforceAuthorizationAtCentralPoint(UserService.class, UserAuthorizer.class);
\end{lstlisting}
\end{minipage}

\subsection{Messages are sent from a central point}
% Description
The third constraint dictates that all outbound messages are sent from a central sending point. The intent is to have a single point that handles output sanitization or performs other safety checks on messages before they are sent. The act of sending a message is defined as a method call to a sender with at least one argument, which is assumed to contain the message contents. The reasoning is that any class should be allowed to create and pass around a sender instance without violating the constraint.

% Rule definition
The rule definition can be seen in Listing~\ref{lst:constraint_3_impl}. Since there can be multiple sender classes in a system, e.g. one for HTTP requests and one for SMTP messages, the rule accepts a predicate that can select all these sender classes.

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Rule definition for constraint 3.}, captionpos=b, label=lst:constraint_3_impl, numbers=left]
ArchRule sendOutboundMessagesFromCentralPoint(
        Class<?> sendingPoint,
        DescribedPredicate<? super JavaClass> senderDescriptor) {
    return methods()
        .that().areDeclaredInClassesThat(senderDescriptor)
        .and(haveAtLeastOneParameter)
        .should(onlyBeAccessedBy(sendingPoint));
}
\end{lstlisting}
\end{minipage}

% Applied to toy app
Listing~\ref{lst:constraint_3_toy} showcases how the constraint can be applied to the example system. In this system, there is a single sender class \texttt{HttpResponse}, responsible for returning a response to a client. The central sending point is the \texttt{OutboundMessageSanitizer} class. 

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Application of constraint 3 to the example system.}, captionpos=b, label=lst:constraint_3_toy, numbers=left]
@ArchTest
ArchRule centralSendingPoint = SecArchUnit
    .sendOutboundMessagesFromCentralPoint(
        OutboundMessageSanitizer.class,
        type(HttpResponse.class)
    );
\end{lstlisting}
\end{minipage}




\section{Injecting Information into Source Code}

Some of the architectural constraints require that the developer injects additional information into the source code. In some cases, this information is simply an indicator that says something about an entire class. Naming the class with a specific suffix is one approach to accomplish this. Another approach is to implement an empty interface, which is the technique used with Java's \texttt{Serializable}\footnote{https://docs.oracle.com/javase/7/docs/api/java/io/Serializable.html} interface. 

In other cases, however, the information may be required for methods of arbitrary signatures and even specific fields. For the purposes of flexibility and minimizing the obtrusiveness of our approach, any extra information is expressed in the form of annotations. These can be applied to classes, fields, methods and parameters without changing the underlying architecture of the system.

The need for additional information within the source code becomes apparent in the case where a class contains public methods with varying degrees of security requirements. A typical example is found in constraint 4, where a class is responsible for handling user input. Some methods might receive predefined values, such as in the case of checkboxes, whereas others treat strings entered by the user.  The former type of input is guaranteed to be safe, whereas the latter entirely under the control of the attacker, thus introducing the need for sanitation. Using the broader predicate of entire classes (described in section \ref{sec:as-is}) would not allow the constraint to be limited to specific methods within a class (those receiving potentially malicious input), and later trace a call to a method providing sanitation. Thus, annotations provide the granularity needed to limit the scope of a constraint to only the applicable code units.

\todo{Specific example that requires additional information}

\todo{Show rule definition for each constraint}
\todo{Show how each constraint is used in our toy app}

\subsection{Validate user input}
User input comes in many forms, and as such, it is impossible to define a single algorithm to validate properly every single type. The problem grows further as queries (such as SQL) or other types of processed data (such as XML), each with its own set of grammar, are often formed using strings. As a consequence, the implemented constraint is more abstract as it checks whether a class that receives user input is said to either perform validation on its own or delegate the task another method. In total, four distinct cases conforming to the constraint where considered: 

\begin{itemize}
    \item \textit{Method A} is annotated with both \textbf{UserInput} and \textbf{InputValidator}.
    
    \item \textit{Method A} is annotated with \textbf{UserInput} and calls a \textit{method B} that is annotated with \textbf{InputValidator}.
    
    \item \textit{Method A} is annotated with \textbf{UserInput} and is only called by methods that are annotated with \textbf{InputValidator}.
\end{itemize}

The rule definition can be seen in Listing~\ref{lst:constraint_4_impl}. As shown, the \textbf{UserInput} annotation is used on line 3 to limit the set of applicable code units, whereas the custom condition \texttt{performDirectOrIndirectValidation} implements the logic to detect violations for each of the three cases outlined above.
    
\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Rule definition for constraint 4.}, captionpos=b, label=lst:constraint_4_impl, numbers=left]
ArchRule validateUserInput() {
    return codeUnits()
        .that().areAnnotatedWith(UserInput.class)
        .should(performDirectOrIndirectValidation);
}
\end{lstlisting}
\end{minipage}

In the example system, a user publishes a status update in the form of a string that the UserService class receives. The status is then passed to the StatusSanitizer class, where it is validated. The affected methods of each class are marked with the appropriate annotation, as shown in Figure~\ref{fig:validate_input_toy_system}. If the two annotations were to be added, without a call from the UserService class to the StatusSanitizer, the ArchUnit rule would fail and mark it as a violation of an architectural constraint.

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{figure/toyexamples/validate_input_toy_system.png}
    \caption{Applying constraint 4 to the model of the example system using added annotations on the UserService and StatusSanitizer class.}
    \label{fig:validate_input_toy_system}
\end{figure}

\subsection{Restrict thread spawning}
While resources is a broad term, this constraint focuses on preventing the exhaustion of CPU and memory resources through the creation of new threads and processes. As such, every block of code that contains a call to the \texttt{start()} method of a \texttt{Thread}\footnote{\url{https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html}} or any of its subclasses, must be marked as containing a resource restriction mechanism. The same rule is applied for calls to \texttt{ProcessBuilder.start()}\footnote{\url{https://docs.oracle.com/javase/7/docs/api/java/lang/Process.html}\label{fnt:java_process}} and \texttt{Runtime.exec()}\footref{fnt:java_process}, which lead to the creation of new processes.

The marking is done with the help of an annotation, either on the relevant method or the entire class. The decision of how the restriction mechanism is implemented is left to the developer of the system.

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Rule definition for constraint 5.}, captionpos=b, label=lst:constraint_5_impl, numbers=left]
ArchRule limitResourceAllocation() {
    return noClasses()
        .that().areNotAnnotatedWith(ResourceRestriction.class)
        .should().callMethodWhere(
            aThreadIsStartedWithoutRestriction
        ).orShould().callMethodWhere(
            aProcessIsStartedWithoutRestriction
        );
}
\end{lstlisting}
\end{minipage}


\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{figure/toyexamples/resource_restriction.png}
    \caption{Applying constraint 5 to the model of the example system using the added annotation on the RequestHandler class}
    \label{fig:toy_resource_restriction}
\end{figure}




\section{Extending ArchUnit Analysis}

In the current ArchUnit API, a rule that aims to constrain method calls can only be defined in terms of the signatures of the method and its parameters. This is a non-issue when the arguments passed to a method are of the same type as the parameters. However, the argument might also be a descendant of the parameter type. There is currently no support in ArchUnit to constrain the types of the objects that are actually being passed as arguments.

Consider constraint 7, which aims to ensure that no secrets are passed to the logger. Say there is a \texttt{Secret} annotation that marks all the classes whose instances must not be passed to the logger. An attempt can be made to enforce the constraint with the current ArchUnit API using a custom predicate, as seen in Listing~\ref{lst:constraint_6_attempt}. Given that a typical logger will accept either a plain string, or a format string along with an array of objects to be formatted, this architectural rule does little in the way of preventing secrets from being passed to such a logger.

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={A first attempt to implement constraint 7.}, captionpos=b, label=lst:constraint_6_attempt, numbers=left]
ArchRule doNotLogSecrets(Class<?> logger) {
    return noClasses()
        .should().callMethodWhere(
            parameterTypeAnnotatedWith(Secret.class)
                .and(targetOwner(type(logger)))
        );
}
\end{lstlisting}
\end{minipage}

For the final 2 constraints, there is a need for an extension that allows constraints to be defined against method arguments rather than parameters. There should also be hints about where these arguments have been derived from, e.g. which types that make up the components of a concatenated string. The following sections describe the extensions that have been made to ArchUnit, both in regards to its analysis and the information represented in its domain, as well as how these extensions are utilized in the definitions of the final constraints.

\subsection{Extensions}
\todo{Parts of this section probably belong in the background}

ArchUnit builds its representation of the architecture using ASM\footnote{\url{https://asm.ow2.io/}}, a Java bytecode analysis framework. ASM reads bytecode and generates callbacks to methods in its various visitor classes\footnote{\url{https://asm.ow2.io/javadoc/org/objectweb/asm/package-summary.html}}. 
The visitor of most interest to us is \texttt{MethodVisitor}, which is responsible for processing the contents of a method, constructor or static initializer. These are collectively named \textit{code units} in ArchUnit's domain, i.e. anything that may contain code.

\begin{figure}
    \centering
    \includegraphics[width=0.6\textwidth]{figure/extension/MethodProcessor1.png}
    \caption{The immediate context of the \texttt{MethodProcessor} class in ArchUnit, responsible for analyzing code units.}
    \label{fig:method_processor_1}
\end{figure}

ArchUnit extends the \texttt{MethodVisitor} class in \texttt{MethodProcessor}, which primarily visits instructions related to field accesses and method invocations (see Figure~\ref{fig:method_processor_1}). These instructions are processed into information about accesses between Java members, not entirely unlike the information provided by a static call graph.

Java, as a stack-oriented programming language, passes arguments to method calls and field assignments via the operand stack \cite{hutchison_information_2005}. As such, an inspection of the operand stack at the time of a method call yields information about the arguments being passed.
Conveniently, ASM provides an extension of its \texttt{MethodVisitor} class, called \texttt{AnalyzerAdapter}, which is capable of simulating the effect that each instruction has on the operand stack. As seen in Figure~\ref{fig:method_processor_2}, \texttt{MethodProcessor} now extends this class and utilizes the information about the operand stack to perform an analysis of information flow within a code unit.

\begin{figure}
    \centering
    \includegraphics[width=0.7\textwidth]{figure/extension/MethodProcessor2.png}
    \caption{Changes made to analysis of code units.}
    \label{fig:method_processor_2}
\end{figure}

The information flow analysis of a code unit can be boiled down to the following key points:

\begin{itemize}
    \item Loading a field onto the stack yields a hint in that stack position about its originating member, i.e. the field.
    \item Invoking a method that has a return value yields a hint in the stack position of the resulting object about its originating member, i.e. the invoked method.
    \item Invoking a static method transfers the hints about the arguments, if any, into the stack position of the resulting object, if the method has a return value.
    \item Invoking a non-static method additionally transfers the hints about the arguments into the instance the method was invoked on, and the hints about the instance into the resulting object.
    \item Storing an object in an array transfers the hints about the object into the array.
    \item Loading an object from an array transfers the hints about the array into the object.
    \item Storing or loading a local variable transfers the hints from the stack to the local variable and vice versa.
    \item Duplicating a reference also duplicates the collection holding the hints for that reference, such that hints that flow into the duplicate also flow into the original reference.
\end{itemize}

Once the analysis of all classes has been completed and ArchUnit has built its representation of the architecture, the raw hints are resolved into hints referencing the actual type (\texttt{JavaClass}) and its origin (\texttt{JavaMember}), if any. As seen in Figure~\ref{fig:domain_changes_1}, \texttt{JavaAccess} now contain hints about the references that flow into the arguments. Additionally, \texttt{JavaMethod} contains hints about the references that flow into the return value of the method. These changes to the domain aim to facilitate the definition of rules that constrain information flow.

\begin{figure}
    \centering
    \includegraphics[width=0.7\textwidth]{figure/extension/DomainChanges1.png}
    \caption{Changes made to the domain surrounding code units.}
    \label{fig:domain_changes_1}
\end{figure}

\todo{Show rule definition for each constraint}
\todo{Show how each constraint is used in our toy app}
\subsection{Sensitive information must stay within trust boundary}
% Description
Constraint six aims to constrain how assets that consist of sensitive information are allowed to flow between components. The constraint deals with the two concepts of assets and asset handlers, which are expressed in the form of \texttt{Asset} and \texttt{AssetHandler} annotations. An asset is a field that should only flow to classes marked with a high security level, i.e. an asset handler.

% Rule definition
The definition of the rule can be seen in Listing~\ref{lst:constraint_6_impl}. The rule itself requires no arguments, as all the necessary information is injected into the source code in the form of annotations. The custom condition, \texttt{notBleedToInsecureComponents}, utilizes the information flow extension to ensure that the assets only flow into code units belonging to classes marked as asset handlers.

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Rule definition for constraint 6.}, captionpos=b, label=lst:constraint_6_impl, numbers=left]
ArchRule doNotBleedAssetsBetweenComponents() {
    return fields()
        .that().areAnnotatedWith(Asset.class)
        .should(notBleedToInsecureComponents);
\end{lstlisting}
\end{minipage}

% Applied to toy app
In the example system, the \texttt{password} field is considered an asset, while \texttt{UserLoginRequest} and \texttt{UserAuthenticator} are considered asset handlers (see Figure~\ref{fig:assets_toy_system}).

\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{figure/toyexamples/Assets.png}
    \caption{Application of constraint 6 to the example system.}
    \label{fig:assets_toy_system}
\end{figure}

\subsection{Secrets must not be exposed in log messages}
% Description
The seventh and final constraint dictates that secrets must not flow into a logger. 

% Rule definition
The architectural rule is defined in Listing~\ref{lst:constraint_7_impl}. 

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Rule definition for constraint 7.}, captionpos=b, label=lst:constraint_7_impl, numbers=left]
ArchRule doNotLogSecrets(
        DescribedPredicate<? super JavaClass> loggerDescriptor) {
    return noClasses()
        .should().callMethodWhere(
            targetOwner(loggerDescriptor).and(passSecretArgument)
        );
\end{lstlisting}
\end{minipage}

% Applied to toy app
\begin{figure}
\centering
\begin{minipage}{.6\textwidth}
  \centering
    \begin{lstlisting}[label=lst:constraint_7_rule, numbers=left]
@ArchTest
ArchRule doNotLogSecrets =
    SecArchUnit.doNotLogSecrets(type(Logger.class));
    \end{lstlisting}
  \label{fig:test1}
\end{minipage}%
\begin{minipage}{.4\textwidth}
  \centering
  \includegraphics[width=.4\linewidth]{figure/toyexamples/Secrets.png}
  \captionof{figure}{Another figure}
  \label{fig:test2}
\end{minipage}
\end{figure}



\begin{figure}
    \centering
    \includegraphics[width=0.3\textwidth]{figure/toyexamples/Secrets.png}
    \caption{Application of constraint 7 to the example system.}
    \label{fig:assets_toy_system}
\end{figure}