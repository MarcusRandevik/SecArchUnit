\chapter{Discussion}

\todo{Tool comparison}
\todo{Discuss examples of things that the tools won't catch}
% different levels of assets, i.e some fields are more sensitive than others

\section{Comparing Static Analysis Tools}
ArchUnit, SonarQube and PMD are all static analysis tools with support for evaluation of custom rules. However, they differ quite a bit in how their rules are defined and evaluated.

ArchUnit first builds a representation of the entirety of the analyzed system, which is then available during the evaluation of the rules. As shown throughout Chapter~\ref{ch:enforcing_constraints}, rules have direct access to information about incoming and outgoing accesses to all fields, code units and classes, making it convenient to specify intricate architectural constraints.

Regarding SonarQube and PMD, both of these tools evaluate rules against an Abstract Syntax Tree (AST) where the root node is the Java class currently being analyzed (see examples in Appendix~\ref{apx:sonarqube} and Appendix~\ref{apx:pmd}). As a consequence, a rule can only inspect one class at a time; it can audit outgoing accesses to other classes, but it does not know anything about incoming accesses to the current class and its members.
In a constraint where incoming accesses to a certain class need to be constrained, the rule can inspect all classes one by one and look for outgoing accesses to the concerned class. However, constraints that define more intricate control flows, such as allowing a given combination of incoming and outgoing accesses, are not enforceable in these tools.
% C4, third case, as example

Rule definitions - Abstract Syntax Trees (SonarQube \& PMD) vs higher-level abstraction (ArchUnit)

Analysis of references - why PMD fails

Semantic information

\section{Threats to Validity}

\subsection{Construct Validity}

\subsection{Internal Validity}

\subsection{External Validity}

\section{Future Research}

Productivity when applying the tool to a new project

Decreased architectural violations over time


