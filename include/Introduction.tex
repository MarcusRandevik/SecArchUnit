\chapter{Introduction}
In the age of an ever more digitalized world, ensuring the security of software systems becomes an increasingly more critical task. The increased severeness is true in particular, as systems are being developed based on the principle of permanent connectivity \cite{felderer_security_2016}.  Services ranging from those offered by governmental agencies to that of social media are always connected to the open internet, potentially creating a large surface of attack. Although the great importance of a securely designed system is widely known, developing a secure system is a challenging task as far from all software engineers are security specialists, or for that matter, particularly educated in security aspects \cite{yoshioka_survey_2008}.

Introducing a weakness into a system can be done in every part of the software development lifecycle. An early introduction often leads to a more costly fix as the scope of the flaw is increased \cite{mcgraw_software_2004}. Typically, weaknesses are categorized as either implementation bugs (e.g. buffer overflow) or design flaws (e.g. client-side validation) where the later commonly has a more extensive scope and is the responsibility of the architect \cite{arce_avoiding_2014}. However, this binary division might be too simplified as it assumes a securely designed is correctly implemented, meaning that there is no discrepancy between the "intended architecture" and the actual one found in the source code. Jasser \cite{franch_constraining_2019} considers violations of the architectural security design as a third type of category with a comparable impact to that of design flaws.

Deviations from the intended architecture are not unique to the initial implementation of a system. Over time, subsequent changes made to the system, often due to new requirements, frequently lead to further disparency called software erosion \cite{de_silva_controlling_2012}. Proponents of the agile methodology also somewhat worsen the problem of erosion as the reduction of upfront design severely hinders the design of the architecture \cite{van_gurp_design_2002}. Many of the tools and techniques produced by academia to try and remedy the frequent violations of architectural design have failed to gain much adoption in the industry \cite{de_silva_controlling_2012}.  Of the few that have, architectural design documentation is the most prominent and widely included in numerous software processes. While the technique is well adopted, performing it formally to allow for automatic compliance monitoring is seldomly done, which causes developers to rely on the less scalable method of manual reviews \cite{de_silva_controlling_2012}.

A recently developed tool called ArchUnit\footnote{https://www.archunit.org/} has provided architects with the capability to express architectural constraints trough Java unit testing frameworks. ArchUnit is not the first tool developed for architectural conformance checking. It possibly is, however, the first to leverage already existing testing infrastructure (Unit testing) in a manner that allows for testing over time. In its current form, ArchUnit has not provided any explicit functionality to test security constraints. Thus, the objective of this thesis is to explore the feasibility of expressing and enforcing typical security architectural constraints trough ArchUnit.

\section{Scope}

This study focuses on architectural measures that aid in fulfilling a security goal. Moreover, these measures should be possible to enforce through static analysis of Java bytecode. Any measures related to the configuration (of an application or operating system), the file-system, or other run-time properties that cannot be validated through static code analysis are deemed to be out of scope.

\section{Research questions}
To fulfill the objective of the study, the following research questions have been defined:

\begin{itemize}
    \item RQ1: What architectural security constraints can be validated using the tool?
    \item RQ2: What modifications can be made to the tool in order to facilitate the validation of additional constraints?
\end{itemize}

\section{Research contribution}

This study aims to show how architectural security constraints can be validated with the help of a static analysis tool. The thesis demonstrates applications of the tool to several open source systems, over time, in an evaluation of its efficacy and precision in terms of detecting violations of constraints.

\section{Limitations}
\label{sec:limitations}

The thesis, and the modified version of ArchUnit, is not aimed at being a complete solution for all security architectural constraints. Instead, the study is performed to provide an initial evaluation of the possibility of using ArchUnit as an alternative to already existing techniques of static conformance checking. 

The principle of ArchUnit may very well apply to programming languages other than Java. Though, the limited scope of the thesis makes it unfeasible to provide functionality to analyze source-code in additional languages.

\section{Thesis outline}

The remainder of this report is structured as follows.
\todo{Outline chapters}

Chapter 2: Provides a general background to the topic of software architecture and architectural security constraints. In addition, the ArchUnit framework is introduced and compared to previously developed tools for architectural conformance.  

Chapter 3:
design of our evaluation,
how systems are chosen,
the protocol for testing the tool,
how to assert the ground truth,
process of mapping constraints to rules

Chapter 4:
composing the architectural constraints,
our final constraints, what they prevent and how they are expressed


Chapter 5:
expressing and enforcing constraints with the tool,
the identification of missing information / tool features

Chapter 6:
results from the empirical validation

Chapter 6:
discussion,
answer our research questions

Chapter 7:
conclusion